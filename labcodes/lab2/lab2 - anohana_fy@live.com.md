#lab2 report
##练习1：实现first-fit连续物理内存分配算法

1. 修改default_init_memmap
  - 对于每一页
    - 修改该页的flags&property为0
    - 通过set_page_ref置ref为0, SetPageProperty置flags中的PG_property位（即第一位）为1
    - 将该页添加到free_list的末尾: list_add_before( &free_list, &(p->page_link) )
  - 将第一页(base)的property置为n
  - 空闲链表页数加n: nr_free += n
2. 修改default_alloc_pages
  - 顺序检查每页，直到查找到页数 >= n的页（该页为起始页）或者查找失败，失败返回NULL
  - 顺序从空闲链表中删除得到的n页，且置这里的每页PG_Reserved(flags的第0位）为1, PG_Property为0
  - 如果页数N大于n，则将第n + 1页(从1算起）的property置为N-n
  - 总页数-n
  - 返回起始页的地址
3. 修改default_free_pages
  - 将每一页的flags&property&ref置0,PG_Property为1
  - 起始页property改为n
  - 在空闲页链表中顺序查找每一页，直到找到页地址大于base + n的页p  // 可以不用+ n，因为页地址是连续的
  - 从p往前插入要释放的每一页, list_add_before( le, &(base->page_link) ); base++;
  - 检查右边是否可以合并，可以的话合并（修改双方的property）
  - 检查左边，同样（左边改peoperty会比较麻烦，这里要往前找，直到找到property不为0的页）
  - 总数 + n

####优化：
  - 释放函数不必先将修改每页属性再添加到链表，可以在添加的时候顺便修改；
  - 修改左边的property应该会有更方便的方法

##练习2：实现寻找虚拟地址对应的页表项
  1. 以虚地址la的高10位为索引，在页目录中找到对应的页目录项pdep
  2. 判断该页目录项对应的页表是否存在（最低位是否为1)，如不存在，则根据条件分配新页表
      - 新分配一页page，设置ref为1，清空该页
      - 将该页对应的物理地址（高20位）赋给pdep，且加上标记
  3. 将pdep高20位转为虚地址，再以la的中间10位为索引，找到页表项，并返回该项的地址

- 请描述页目录项和页表项中每个组成部分的含义和以及对ucore而言的潜在用处
  ```
  页目录项高20位为页表的高20位物理地址，其他12位为标记位，
  其中第0位为存在位，第1位为可写，第2位为用户可访问，其他保留。
  页表项高20位为对应页的高20位物理地址，其他12位为标记位，同上。
  标记位可以用来检查权限，判断页是否存在等等，同时也可以减少管理页表所需的内存
  ```
- 如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？
  ```
  硬件会产生中断，将一些值压进堆栈，并跳转到对应的中断服务例程
  ```

##练习3:释放某虚地址所在的页并取消对应二级页表项的映射
1. 判断所释放的页是否存在（页表项最低位为是否1），不存在则不处理
2. 根据页表项获得对应的页page（由于每一页按4KB对齐，所以通过高20位即可获得其地址）
3. 将page的ref减1,如果减为0,则释放该页
4. 清除页表项的内容：将其值改为0，如果只是将最低位（存在位）改为0,可能不利于往后的扩展
5. 更新TLB

- 数据结构Page的全局变量的每一项与页表中的页目录项和页表项有无对应关系？
  如果有，其对应关系如何？
```
与页目录项无关，页表项中存储的高20位地址与Pages一一对应，以该地址为索引即为对应的页
```
- 如果希望虚拟地址与物理地址相等，则需要如何修改lab2，才能完成此事？
```
将memlayout.h中的KERNBASE改为0X00000000
```
